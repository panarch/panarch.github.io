## Day 1 – Thursday, Oct 9

### Are We Desktop Yet? Challenges and stories of writing a desktop environment in Rust
> `10:00–10:45 · Main Stage`
> 발표자: Victoria Brekenfeld (System76)
> [세션 링크](https://eurorust.eu/2025/talks/are-we-desktop-yet/)

컨퍼런스의 첫 세션이었습니다.
처음엔 솔직히 꽤 생소했습니다. Rust로 데스크톱 환경을 만든다는 게 왜 필요한 일인지, 왜 굳이 직접 툴킷까지 새로 만들어야 하는지 쉽게 납득이 되지 않았습니다.
하지만 이야기를 듣다 보니, 단순히 기술적인 호기심을 넘어서 리눅스 데스크톱을 Rust로 완전히 새롭게 정의하려는 시도라는 점이 흥미로웠습니다.

System76은 기존 GTK나 Qt 같은 툴킷을 쓰지 않고, Rust로 자체 GUI 툴킷과 컴포지터까지 직접 개발하고 있습니다.
기술적으로도 대단하지만, "Rust-native한 데스크톱 환경"을 진지하게 현실로 만들려는 철학적 선택이라는 점이 인상 깊었습니다.
COSMIC은 Wayland 위에서 동작하며, 발표자가 오랫동안 개발해온 Smithay 프레임워크를 기반으로 만들어졌습니다.

저는 원래 egui, Iced, Slint 같은 Rust GUI 프레임워크나, ratatui, cursive 같은 TUI 라이브러리를 자주 보고 있었기 때문에
"왜 기존의 선택지 대신 직접 만들어야 했는가?"라는 부분이 특히 흥미로웠습니다.
결국 이들의 접근은 "지금 있는 걸 조합해서 쓰기엔 Rust 생태계가 아직 준비되지 않았다면, 우리가 그 기반부터 만들어보자"는 결정이었습니다.

세션 이후에는 Pop!_OS와 System76이라는 회사에 대해서도 찾아보았습니다.
Pop!_OS는 Ubuntu 기반의 배포판으로, System76의 하드웨어에 최적화되어 있습니다.
System76은 단순히 리눅스 노트북이나 데스크톱을 판매하는 회사가 아니라, 운영체제와 데스크톱 환경까지 직접 설계하고 통합하는 곳이었습니다.
하드웨어 제조사가 OS와 GUI까지 직접 만든다는 건 국내에서는 거의 보기 힘든 케이스라 처음엔 낯설었지만,
알고 보니 오히려 그 낯섦이 이 회사의 진정한 강점이었습니다.
그들의 시도는 단순히 제품 개발을 넘어서, **"리눅스 데스크톱 전체를 더 나은 방향으로 끌어올리려는 움직임"**으로 느껴졌고,
이제는 정말 응원하고 싶다는 생각이 들었습니다.

### Exemplary by Design: Building and Maintaining Rust at Scale
> `11:00–11:30 · Main Stage`
> 발표자: Jacob Pratt (Rust Foundation Fellow)
> [세션 링크](https://eurorust.eu/2025/talks/building-and-maintaining-rust-at-scale/)

이 세션은 대규모 Rust 코드베이스를 어떻게 ‘Rust스럽게’ 유지할 것인가에 대한 이야기였습니다.
테스트, 코드 커버리지, 파일 구조, lint 규칙, 빌드 속도 관리 등 - Rust의 여러 강점을 어떻게 체계적으로 적용할 수 있는지를 전반적으로 다뤘습니다.

전반적으로는 평이한 내용이 많았지만, Rust의 핵심적인 강점들을 정리해주는 세션이라 들으면서 "이래서 Rust가 안정적인 대규모 프로젝트에 적합하구나"라는 걸 다시 한번 느낄 수 있었습니다.
코드 스타일과 구조, 모듈화, 빌드 속도 등 **‘규모가 커질수록 더 중요해지는 설계 기준들’**을 Rust 관점에서 풀어낸 점이 좋았습니다.

특히 기억에 남은 건 에러 처리(Error handling) 부분이었습니다.
Jacob은 "Error enum을 struct로 감싸는 방법"을 제안했는데, 이 접근이 꽤 흥미로웠습니다.
보통 라이브러리에서 error enum을 그대로 외부에 노출하곤 하는데,
enum의 variant가 바뀌거나 추가될 때마다 breaking change가 되어버리는 문제가 있죠.
그런데 한 번 struct로 감싸서 그 struct를 public API로 노출하면,
내부 enum의 변화가 외부에 직접적인 영향을 주지 않기 때문에 훨씬 유연하게 유지보수가 가능해집니다.

물론 현실적으로는 라이브러리 사용자가 모든 에러 케이스를 일일이 처리하지 않기 때문에,
이 방식을 무조건 따라야 하는가에 대해서는 고민이 남습니다.
하지만 "이런 식으로 error 설계의 안정성을 확보할 수 있다"는 발상 자체가 꽤 인상적이었고,
개인적으로도 앞으로 error 타입을 설계할 때 다시 한 번 생각해볼 만한 아이디어였습니다.

### From any to this: using concrete error types instead of a catchall
> `11:45–12:15 · Main Stage`
> 발표자: Leo Kettmeir (Deno Project)
> [세션 링크](https://eurorust.eu/2025/talks/from-any-to-this/)

이 세션은 **Deno 프로젝트가 기존의 anyhow 기반 에러 핸들링을 버리고, thiserror를 활용한 구체적인 에러 타입(concrete error types)**으로 전환한 과정을 다룬 발표였습니다.
anyhow는 초기에 빠르게 개발하기엔 편리하지만, 모든 에러를 하나로 감싸다 보니 규모가 커질수록 에러의 출처를 추적하거나 타입 안정성을 유지하기 어려워지는 문제가 생깁니다.
Deno 팀은 이를 해결하기 위해 수십 개의 crate에 걸친 대규모 리팩터링을 진행했고, 모듈별로 명확한 에러 타입을 정의하면서 장기적인 유지보수성과 명시성을 확보했다고 합니다.

저는 개인적으로 주로 Rust 라이브러리 프로젝트를 개발해왔기 때문에, 현실적으로 거의 thiserror만 사용하고 있었습니다.
그래서 이 발표의 방향성에는 전반적으로 공감이 갔습니다.
특히 Deno처럼 JS 런타임 위에서 동작하며 다양한 언어 경계를 넘나드는 프로젝트라면, 초기에 anyhow를 도입할 수밖에 없었을 거라는 판단도 충분히 이해되었습니다.
그럼에도 불구하고, 시간이 지나며 thiserror로 전환해 더 명확하고 유지보수 가능한 구조로 나아간 점이 인상적이었습니다.
현실적인 타협과 이상적인 설계 사이에서 점진적으로 개선해가는 과정을 보여준 사례로, 실제 현업에서도 생각해볼 만한 부분이 많았습니다.

**12:15–13:45 · Lunch**

### Production Unsafe Rust: Patterns for Zero-Copy Performance
> `13:45–14:15 · Main Stage`
> 발표자: Muskan Paliwal
> [세션 링크](https://eurorust.eu/2025/talks/production-unsafe-rust/)

Rust를 5년 넘게 사용해오고 있지만, 사실상 unsafe 영역을 직접 다뤄본 경험은 거의 없었습니다.
그래서 지금까지는 "unsafe는 성능에 극도로 민감한 시스템에서나 필요한, 나와는 조금 먼 이야기" 정도로만 생각했고, 자연스럽게 관심도 많지 않았습니다.
그런 상태에서 들은 이 세션은 예상외로 꽤 흥미로웠습니다.

발표자는 Safe Rust의 성능적 한계가 구체적으로 어디서 드러나는지를 현실적인 예시를 통해 설명했습니다.
메모리 복사, 버퍼 할당, SIMD 최적화 등에서 실제로 어떤 지점에서 병목이 생기는지, 그리고 왜 그럴 때 unsafe 코드가 도움이 되는지를 이해하기 쉽게 풀어냈습니다.
단순히 "unsafe를 써도 된다"가 아니라, 언제 unsafe를 선택해야 하고, 그 이후 코드를 어떻게 안전하게 관리할 것인지에 초점을 맞춘 점이 인상적이었습니다.

특히 프로덕션 코드에서 unsafe를 사용하는 구체적인 패턴과, 팀 단위로 그 코드를 리뷰하고 유지보수하기 위한 원칙을 소개한 부분이 좋았습니다.
이야기를 들으며 "unsafe를 두려워하지 말고, 필요할 때 책임 있게 사용할 수 있는 역량을 갖추는 게 중요하겠구나"라는 생각이 들었습니다.

아직 제 프로젝트에서는 직접 unsafe를 다룰 일이 없겠지만, 이 세션 덕분에 "어떤 상황에서 unsafe가 필요할지, 그리고 그때 어떤 접근이 합리적인지"를 좀 더 명확히 이해하게 되어 매우 유익했습니다.

### Roto: a fast and safe scripting language
> `14:30–15:00 · Main Stage`
> 발표자: Terts Diepraam (NLnet Labs)
> [세션 링크](https://eurorust.eu/2025/talks/roto-scripting-language/)

이 세션은 NLnet Labs가 자체적으로 개발한 정적 타입 스크립트 언어 Roto를 소개하는 발표였습니다.
NLnet Labs는 BGP 엔진 Rotonda를 Rust로 개발하면서, 기존의 스크립트 언어들이 성능이나 안정성 면에서 요구사항을 충족하지 못해 직접 언어를 만드는 선택을 했다고 합니다.
Roto는 정적 타입 기반의 Rust 유사 문법을 가지고 있으며, Cranelift를 사용해 머신 코드로 컴파일되는 구조라 빠르고, Rust와의 상호 연동성도 뛰어납니다.
Rust 코드에 쉽게 임베드할 수 있고, Rust에서 정의한 타입과 함수를 Roto 내부에서 직접 사용할 수 있다는 점이 핵심입니다.

개인적으로 Rust로 만든 스크립트 언어들(Gleam, Rhai 등) 에는 예전부터 관심이 많았습니다.
특히 GlueSQL에 임베드할 수 있는 스크립트 언어를 찾고 있었기 때문에, 이번 발표는 더 흥미로웠습니다.
제가 찾던 조건이 "정적 타입"이면서 "Rust 프로젝트에 자연스럽게 임베드 가능"인 언어였는데, 이 두 가지를 모두 만족하는 사례를 찾기 어려웠던 만큼 Roto가 상당히 눈에 띄었습니다.

아직은 문서나 생태계 측면에서 초기 단계라는 느낌을 받았지만, 이미 NLnet Labs의 **실제 사용 사례(BGP 엔진 내부 정책 스크립팅)**를 기반으로 발전 중이라, 꾸준히 관리될 가능성이 높다고 느꼈습니다.
다만 Roto가 장기적으로 범용 프로그래밍 언어로 확장되려면, NLnet Labs의 네트워크 도메인을 넘어선 다양한 분야의 기여자와 피드백이 필요해 보였습니다.

전반적으로 Rust 생태계 안에서 "정적 타입 기반의 내장용 스크립트 언어"가 현실화되는 흥미로운 시도였고, GlueSQL과 같은 프로젝트에서 어떻게 응용할 수 있을지 생각해보게 된 유익한 세션이었습니다.

### Trust Your Benchmarks, Not Your Instincts: A Rust Performance Quiz
> `15:15–15:45 · Main Stage`
> 발표자: Arthur Pastel & Adrien Cacciaguerra (CodSpeed)
> [세션 링크](https://eurorust.eu/2025/talks/trust-your-benchmarks/)

가볍게 들을 수 있었던 재미있는 세션이었습니다.
두 코드 중 어떤 쪽이 실제로 더 빠를지를 맞춰보는 퀴즈 형식으로 진행됐는데, 단순한 이론 설명이 아니라 직접 비교를 통해 체감할 수 있어서 흥미로웠습니다.

Rust는 컴파일러가 워낙 똑똑해서 대부분의 경우 알아서 최적화를 잘 해주지만, 생각하지 못한 코드가 예상 밖으로 더 빠른 경우도 꽤 있었습니다.
반복자 체이닝이나 메모리 할당, 단순한 루프 차이처럼 사소해 보이는 부분에서도 실제 성능은 달라질 수 있었고, 이런 예시들을 보며 "감"이 아니라 벤치마크 데이터로 판단해야 한다는 메시지가 확실히 와닿았습니다.

또 이 세션을 진행한 CodSpeed 팀은 행사장 내에 부스도 함께 운영하고 있었는데, 단순한 회사 홍보보다는 이렇게 참여형 세션을 통해 자연스럽게 자사 제품의 필요성을 보여주는 방식이 인상적이었습니다.
"벤치마크가 중요하다"는 메시지와 CodSpeed의 지속적 성능 분석 도구가 자연스럽게 연결되어, 재미와 실용성, 그리고 제품 홍보까지 모두 잘 어우러진 좋은 발표 주제였다고 느꼈습니다.

전체적으로는 부담 없이 즐길 수 있는 세션이었지만, 동시에 Rust 코드의 성능 최적화에서 직관이 얼마나 자주 틀릴 수 있는지를 잘 보여준 유익한 시간이었습니다.

**15:45–16:15 · Snack Break**

### Reflection on the humans powering Rust ecosystem
> `16:15–16:45 · Main Stage`
> 발표자: Rohit Dandamudi (Rust Foundation Fellow, UBC Research Engineer)
> [세션 링크](https://eurorust.eu/2025/talks/reflections-on-the-humans/)

이 세션은 Rust 생태계를 만들어가는 사람들에 초점을 맞춘 발표였습니다.
기술적인 이야기보다는, Rust 커뮤니티의 다양성과 구조적인 문제를 데이터로 분석하고 이를 개선하기 위한 움직임에 대해 다뤘습니다.
기여자들의 활동 데이터를 기반으로, 어떤 지역과 배경의 사람들이 Rust 발전을 이끌고 있는지, 그리고 어디서 불균형이 발생하고 있는지를 살펴보는 연구형 세션이었습니다.

특히 커뮤니티의 다양성과 포용성이라는 주제가 기술 세션들 사이에서 신선하게 느껴졌습니다.
작년에 RustConf 2024 몬트리올에서도 비슷한 주제의 세션을 들었는데,
그때와 마찬가지로 Rust 커뮤니티가 단순한 코드 기여를 넘어, 사람과 문화의 다양성을 고민하고 실제로 개선하려는 움직임을 보고 인상 깊었습니다.

물론 이런 문제들은 한 번에 해결하기 어렵고, 현실적인 한계도 존재합니다.
그럼에도 불구하고 Rust 커뮤니티가 그러한 상황을 외면하지 않고, 지속적으로 개선하려는 방향성 자체를 유지하고 있다는 점이 좋았습니다.
또한 이번 EuroRust 2025의 발표자 구성 자체에서도 다양성을 고려한 배분이 이루어졌다는 인상을 받았는데,
이 세션의 주제 선정 역시 그 연장선에 있는 듯해 컨퍼런스 전체의 섬세한 기획 의도가 느껴졌습니다.

전반적으로 Rust 생태계를 기술이 아닌 사람의 관점에서 바라볼 수 있었던 의미 있는 시간이었습니다.

### Rendering at 1 million pixels / millisecond with GPUI
> `17:45–18:30 · Main Stage`
> 발표자: Conrad Irwin (Zed)
> [세션 링크](https://eurorust.eu/2025/talks/rendering-at-1-million-pixels-millisecond-with-gpui/)

Zed는 작년 RustConf 2024 몬트리올에서도 스폰서로 참여해 부스를 운영했었는데,
그때 직접 이야기를 나눌 기회도 있었고, 개인적으로도 이미 자주 사용하던 에디터라 관심이 많았습니다.
작년에는 Lapce도 함께 써보다가, 결국 Zed로 기본 에디터를 완전히 갈아탄 시점이었는데요.
당시엔 더 자유로운 Apache-2.0 라이선스를 채택한 Lapce 쪽이 마음이 갔지만,
실제 사용성과 완성도 측면에서는 결국 Zed의 손을 들어줄 수밖에 없었습니다.

작년 RustConf에서는 Zed 팀이 스폰서 라이트닝 톡 세션으로 5분 정도 나와
자사 제품을 소개하기보다는 Zed의 파일 트리 렌더링 구조가 얼마나 빠른가만 보여주고 내려갔던 게 기억에 남았습니다.
그때부터 이미 "참 특이한 방식의 회사"라는 인상을 받았는데,
이번 EuroRust에서는 45분짜리 온전한 세션으로 돌아왔습니다.

이번에도 발표 방식은 여전히 독특했습니다.
발표자는 절반 이상의 시간을 자신의 어린 시절 이야기와 Superhuman CTO로서의 경험에 할애했고,
슬라이드 없이 직접 말로만 풀어냈습니다.
부모님이 이미 개발자였다는 이야기도 흥미로웠는데,
미국은 개인용 컴퓨터 보급이 빨랐던 만큼 한 세대 일찍 개발자 문화가 형성된 배경을 엿볼 수 있었습니다.

이후에는 본격적으로 Zed의 렌더링 엔진 GPUI 소개로 이어졌습니다.
Zed는 오픈소스로 코드를 공개하고 있지만, 대부분 AGPL이나 GPL 기반이라
사실상 코드를 "열람"할 수는 있어도 "활용"하기는 어려운 구조였습니다.
그런데 이번 GPUI만큼은 Apache-2.0 라이선스로 공개하면서
정말로 외부 개발자들의 사용을 염두에 두고 있다는 점이 매우 인상적이었습니다.
작년에 코드를 직접 봤을 때만 해도 Zed 내부 렌더링 엔진은
외부에서 활용할 수 없는 구조였는데, 이번에는 많이 개선되어 실제 사용 가능한 형태로 발전한 모습이었습니다.

성능 측면에서도 이미 Zed 에디터를 통해 충분히 검증된 만큼 신뢰가 갔습니다.
무언가 굳이 써볼 이유를 만들고 싶을 정도로 흥미로운 프로젝트였습니다.
아직은 초기 단계라 문서화가 부족하고, 기본 컴포넌트 위주로만 구성되어 있지만,
텍스트 에디터 컴포넌트도 GPUI의 기본 구성요소로 함께 공개해주었으면 하는 바람이 생겼습니다.
발표 이후 코드를 직접 둘러봤을 때는 아직 포함되어 있지 않았지만,
그럼에도 GPUI의 방향성과 완성도는 충분히 응원하고 싶은 프로젝트였습니다.

## Day 2 – Friday, Oct 10

### Rewrite, Optimize, Repeat: Our Journey Porting a Triemap from C to Rust
> `10:00–10:45 · Main Stage`
> 발표자: Luca Palmieri (MainMatter)
> [세션 링크](https://eurorust.eu/2025/talks/rewrite-optimize-repeat/)

이 세션은 Redis의 검색 기능 일부를 C에서 Rust로 포팅하면서, 단순히 언어를 바꾸는 수준을 넘어 어떻게 성능을 개선하고 구조를 재설계했는지를 다룬 발표였습니다.
C의 TrieMap 구현을 Rust로 옮기는 과정에서 단순 변환이 아니라 데이터 구조와 메모리 모델을 Rust 철학에 맞게 다시 설계한 사례였고,
결국 C보다 빠르고 안전한 버전을 만들어냈다는 점이 인상적이었습니다.

특히 전날 들었던 Production Unsafe Rust 세션 이후에 이 발표를 들을 수 있어서 다행이었습니다.
unsafe를 실제로 어떻게 사용하고, 현실적인 성능 개선으로 이어지는지를 구체적인 예시로 볼 수 있었기 때문입니다.
이전 세션이 unsafe의 개념적, 철학적 접근이었다면, 이번 발표는 그걸 실제 대규모 프로젝트에서 어떻게 적용하는지 보여주는 현실판 같은 느낌이었습니다.

그리고 개인적으로 가장 인상 깊었던 부분은 MainMatter라는 회사 자체였습니다.
예전부터 유럽의 IT 컨설팅 회사들에 대해 조금은 들어봤지만,
한국에서는 보기 힘든 형태의 모델이라 이번에 실제 사례를 들으며 흥미로웠습니다.
이 회사는 단순히 인력을 파견하거나 개발 아웃소싱을 하는 곳이 아니라,
특정 기술 분야의 전문가들을 고용하고, 교육하고, 실제 프로젝트(Redis 포팅 같은) 컨설팅을 수행하는 구조를 가지고 있었습니다.
이런 형태의 회사를 어떻게 만들고 운영할 수 있을까,
한국에서도 가능할까 하는 생각이 자연스럽게 들었습니다.

무엇보다 MainMatter가 단순히 참여하는 수준이 아니라,
EuroRust를 공식적으로 후원하고 주요 세션을 직접 발표할 정도로 존재감을 가진 회사라는 점도 인상적이었습니다.
컨퍼런스의 메인 스테이지에서 실제 산업 사례를 기반으로 발표하는 모습을 보면서,
이런 식으로 컨설팅 회사가 기술 생태계에 기여하고 신뢰를 쌓아가는 구조도 있다는 걸 새삼 느낄 수 있었습니다.
### Random Seeds and State Machines: An Approach to Deterministic Simulation Testing
> `11:00–11:30 · Side Stage`
> 발표자: Alfonso Subiotto (Polar Signals)
> [세션 링크](https://eurorust.eu/2025/talks/random-seeds-and-state-machines/)

Concurrent한 상황에서 발생하는 버그는 정말 재현이 어렵습니다.
이 세션은 그런 어려운 문제를 다루는 매우 흥미로운 사례로 시작했습니다.
발표자가 소개한 예시는, 특정 환경에서 시스템을 돌리면 약 3시간쯤 지나서야 발생하는 버그였습니다.
아주 특정한 조건에서만 일어나고, 재현하려면 몇 시간을 기다려야 하는 데다,
원인 파악도 쉽지 않은 그런 전형적인 분산 환경의 문제였습니다.

그런데 발표에서 인상적이었던 부분은 “concurrent한 문제는 원래 어렵다”로 끝나는 이야기가 아니라,
이런 상황조차 재현 가능하게 만들려는 시도였습니다.
단순한 fuzzing처럼 무작위로 이벤트를 던지는 게 아니라,
실패나 이벤트를 무작위로 주입하면서도 그 실행 경로를 random seed로 고정해 완전히 동일한 상황을 다시 재현할 수 있게 만든다는 점이 정말 인상 깊었습니다.

이 방법을 통해 분산 시스템에서 일어나는 다양한 비결정적 상황 속에서도,
그나마 “잡을 수 없는 버그”들을 다시 reproducible하게 만들어 디버깅할 수 있게 된다는 점이 매우 현실적인 접근으로 느껴졌습니다.
물론 발표 중에도 언급된 것처럼, 이 방식에도 한계는 존재합니다.
모든 상황을 완벽히 재현할 수 있는 것은 아니지만,
어디까지 커버할 수 있고 어디서부터는 한계가 생기는지에 대한 발표자의 시각도 흥미로웠습니다.

특히 “concurrent한 문제는 concurrent하게 테스트해야 한다”는 일반적인 관점에서 벗어나,
결정론적 시뮬레이션을 통해 동일한 실행 흐름을 반복 재현할 수 있게 만든 접근은 굉장히 인상 깊었습니다.
이건 단순한 테스트 기법이 아니라, 분산 시스템에서 신뢰성과 재현성을 확보하는 새로운 패러다임처럼 느껴졌습니다.
### How to Fit an Elephant in a Rusty Refrigerator: Conquering a 7,000-Type API
> `11:45–12:15 · Main Stage`
> 발표자: Kiril Karaatanasov (VMware, Broadcom)
> [세션 링크](https://eurorust.eu/2025/talks/how-to-fit-an-elephant/)

이 세션은 7,000개가 넘는 타입을 가진 레거시 엔터프라이즈 API를 Rust로 옮기는 과정을 다룬 발표였습니다.
수십 년 된 시스템의 복잡한 상속 구조와 느린 컴파일 타임, 수천 개의 타입이 얽혀 있는 거대한 코드를
Rust의 타입 시스템 안에서 어떻게 단순화하고 성능까지 확보했는지를 소개했습니다.

상속 구조는 Trait 기반의 동적 디스패치로 재구성했고,
3,000개 이상의 배열 타입은 Enum으로 통합했습니다.
예외나 이벤트 구조처럼 너무 복잡한 데이터는 serde_json::Value를 활용해 유연하게 감쌌습니다.
또한 매크로 대신 커스텀 코드 생성(codegen) 방식을 채택해 컴파일 타임을 약 90% 단축했다고 합니다.
결국 목표는 “레거시 코드를 Rust로 옮기는 것”이 아니라,
Rust의 타입 시스템으로 복잡성을 길들이는 것이었습니다.

이 세션을 들을 당시에는 단순히 흥미롭게 들었는데,
한국에 돌아와서 VexFlow라는 타입스크립트 기반 악보 렌더링 엔진을 Rust로 옮기는 작업을 취미로 진행하면서
그때 들었던 내용에 공감이 훨씬 더 깊어졌습니다.
물론 제가 하는 건 훨씬 작은 규모의 프로젝트이지만,
다른 언어의 복잡한 구조를 Rust의 타입 시스템에 맞게 옮기는 작업이
생각보다 훨씬 어렵다는 걸 직접 느꼈습니다.

그런데 이 발표에서 다룬 수준의 복잡도,
게다가 컴파일 타임 최적화까지 고민해야 하는 환경이라면
그 난이도는 정말 상상하기 힘들 정도일 것 같았습니다.
그래서 다시 돌아보면, 단순히 흥미로운 발표가 아니라
실제 산업 규모의 코드베이스에서 Rust를 어떻게 현실적으로 적용할 수 있는가를 보여준 귀중한 사례였다고 느껴집니다.

**12:15–13:45 · Lunch**

### A Deep Dive into Serde-Driven Reflection
> `13:45–14:15 · Side Stage`
> 발표자: Ohad Ravid (Wiz)
> [세션 링크](https://eurorust.eu/2025/talks/serde-driven-reflection/)

이 세션은 Serde의 내부 동작을 깊이 파고들며, Rust에서 리플렉션(reflection)에 가까운 기능을 어떻게 구현할 수 있는가를 다룬 발표였습니다.
Rust는 정적 타입 언어라 런타임 리플렉션이 불가능하지만, Serde의 구조를 활용하면 컴파일 타임 수준에서 타입 정보를 다루는 방법을 만들 수 있다는 점을 보여주었습니다.
`#[derive(Deserialize)]` 매크로로 생성되는 실제 코드를 단계별로 분석하며,
Serde가 단순한 (de)serialization 도구가 아니라 Rust의 trait 시스템을 이용한 타입 탐색 메커니즘이라는 것을 잘 드러낸 발표였습니다.

개인적으로 관심은 있었지만 직접 다뤄본 적은 없던 주제라 새로 배운 부분이 많았습니다.
최근 GlueSQL에서 쿼리 결과를 deserialize하기 위한 proc macro를 주요 기능으로 추가한 적이 있는데,
그때는 Serde를 사용하지 않고 직접 proc macro를 만드는 선택을 했었습니다.
이 결정을 내린 것은 작년쯤 검토 후 이미 정리했던 내용이었고, 몇 달 전 실제 구현까지 마쳤습니다.

그런데 이 세션을 들으면서, "왜 Serde 대신 직접 구현하는 방향을 선택했었는지"를 다시 떠올릴 수 있었습니다.
Serde deserializer를 직접 구현한 경험은 없지만, 비슷한 맥락에서 다른 접근을 시도해 본 적이 있었기 때문에
이번 발표 내용이 더 잘 와닿았습니다.
결국 Serde의 내부 원리와 구조를 깊이 이해하면,
Rust에서 타입 안정성과 유연성을 동시에 잡을 수 있는 방법이 얼마나 다양할 수 있는지를 보여준 유익한 세션이었습니다.

### How Rust Compiles
> `14:30–15:00 · Main Stage`
> 발표자: Noratrieb (Rust Compiler Team)
> [세션 링크](https://eurorust.eu/2025/talks/how-rust-compiles/)

이 세션은 우리가 cargo build를 실행할 때 Rust 컴파일러가 내부적으로 어떤 과정을 거쳐 실행 파일을 만들어내는지를 단계별로 설명한 발표였습니다.
타입 검사부터 MIR 생성, LLVM을 통한 코드 생성, 그리고 링킹까지 Rust의 컴파일 파이프라인을 구체적으로 다뤘습니다.
특히 `#[inline]`, LTO, 제네릭 모노모픽화 같은 개념들이 실제로 컴파일 타임과 런타임 성능에 어떤 영향을 주는지를 실제 예시로 보여주었습니다.

개인적으로 잘 모르던 내용이라 유익하고 흥미롭게 들은 세션이었습니다.
Rust를 오랫동안 다뤄왔어도, 실제로 컴파일러 내부 동작 원리까지 깊이 살펴볼 기회는 거의 없기 때문에 새로웠습니다.
특히 `#[inline]` 이 컴파일러가 함수 호출을 최적화하는 과정에서 어떻게 처리되는지를 구체적으로 볼 수 있었던 부분이 인상적이었습니다.
Rust의 안전성과 성능이 단순히 언어의 특성이 아니라, 컴파일러의 정교한 설계와 최적화 과정에서 비롯된 것이라는 점을 다시 느낄 수 있었습니다.

또 이런 종류의 세션이 흥미로운 이유는, 사실 마음만 먹으면 따로 공부할 수 있는 내용이지만
현실적으로는 그렇게까지 시간을 내서 깊게 파고들 일이 많지 않다는 점입니다.
그래서 이렇게 컨퍼런스 현장에서 직접 들을 수 있었다는 것만으로도 의미가 컸고,
오프라인 참여를 통해 자연스럽게 새로운 주제에 노출되고 흥미를 확장할 수 있는 기회였다는 점에서 더 유익한 시간이었습니다.

### Misusing Const for Fn and Profit
> `15:15–15:45 · Main Stage`
> 발표자: Tristram Oaten (No Boilerplate)
> [세션 링크](https://eurorust.eu/2025/talks/misusing-const/)

이 세션은 Rust의 **`const` 기능을 활용해 런타임이 아닌 컴파일 타임에 계산을 수행하는 방법**을 다룬 발표였습니다.
제목처럼 “const를 잘못 써서 이득을 본다”는 농담조의 표현이지만, 실제로는 **컴파일 타임 계산과 제로 코스트 추상화의 관계**를 깊이 있게 다룬 내용이었습니다.

Rust에서는 `const fn`을 통해 일부 함수를 컴파일 시점에 실행할 수 있습니다.
이 기능을 적절히 사용하면 반복되는 연산이나 초기화 과정을 미리 계산해두어 런타임 부하를 줄일 수 있습니다.
또한 매크로와 결합하면 런타임 비용 없이 정교한 코드 생성을 수행할 수도 있습니다.
이 발표에서는 그런 컴파일 타임 계산을 실제 프로젝트에서 어떻게 활용할 수 있는지 구체적인 사례를 보여주었습니다.

솔직히 `const fn`에 대해서는 평소에 크게 생각해본 적이 없었는데,
이번 컨퍼런스를 계기로 이렇게 직접 이야기를 들을 수 있어서 재미있었습니다.
발표를 들으며 "이 기능을 좀 더 적극적으로 활용해볼 수도 있겠다"는 생각이 들었고,
세부 내용 중에 기억이 나지 않는 부분도 있어서 영상이 유튜브에 공개되면 한 번 다시 보려고 생각중입니다.

**15:45–16:15 · Snack Break**

### What actually are attributes?
> `16:15–16:45 · Side Stage`
> 발표자: Jana Dönszelmann (Rust Compiler Team, Hexcat)
> [세션 링크](https://eurorust.eu/2025/talks/what-are-attributes/)

이 세션은 Rust 문법 전반에 걸쳐 자주 등장하는 **`#[attribute]`** 가 내부적으로 어떻게 작동하는지를 깊이 다룬 발표였습니다.
우리가 익숙하게 사용하는 `#[derive]`, `#[test]`, `#[tokio::main]`, `#[serde(...)]` 같은 속성들이
겉보기엔 비슷하게 생겼지만 실제로는 **컴파일러에서 전혀 다른 방식으로 처리된다는 점**을 보여주었습니다.

개인적으로 이 세션은 **이번 컨퍼런스에서 가장 흥미로웠던 발표 중 하나**였습니다.
겉으로 보기엔 똑같은 문법처럼 보이는데, 그 안에서 동작 방식과 처리 경로가 이렇게 다양하게 나뉜다는 게 정말 재밌었습니다.
Rust는 attribute를 통해 언어를 유연하게 확장할 수 있도록 설계되어 있다 보니,
**같은 형태의 문법이지만 전혀 다른 역할을 수행하는 경우**가 많습니다.
아주 이상적인 언어라면 이런 것들이 문법적으로 구분될 수도 있겠지만,
그보다는 오히려 Rust의 이런 “인간적인 면모”가 느껴져서 좋았습니다.

특히 발표 후반부의 **컴파일러 리팩터링 사례**가 인상 깊었습니다.
attribute의 자유도 때문에 생긴 예외적인 케이스들을 실제 버그 예시와 함께 소개했는데,
그 과정에서 Rust 컴파일러가 얼마나 유연하면서도 복잡하게 작동하는지를 잘 보여주었습니다.
이런 기술 부채를 하나씩 해결해나가며 언어를 점진적으로 다듬어가는 과정이 흥미로웠고,
Rust의 성숙도가 이렇게 쌓여간다는 점이 인상 깊었습니다.

### Panic! At The Disk Oh!
> `17:00–17:30 · Side Stage`
> 발표자: Jonas Kruckenberg (MainMatter)
> [세션 링크](https://eurorust.eu/2025/talks/panic-at-the-disk-oh/)

이 세션은 Rust에서 **패닉(panic)** 이 실제로 어떻게 동작하는지를 깊이 있게 다룬 발표였습니다.
`unwrap()` 실패나 `assert!` 실패처럼 익숙한 상황에서 프로그램이 종료되는 과정을 단순히 “크래시한다”로 끝내지 않고,
그 내부에서 **스택 언와인딩(stack unwinding)** 이 어떻게 이뤄지는지를 자세히 설명했습니다.
`Drop` 트레이트가 panic 중에도 어떻게 호출되어 리소스를 정리하는지,
그리고 이 과정에서 중첩된 panic이 발생하면 Rust가 어떻게 abort로 전환해 시스템을 보호하는지도 다뤘습니다.

또한 **`catch_unwind` 같은 메커니즘**을 통해 panic 이후의 처리를 제어할 수 있다는 점도 처음 알게 되었는데,
이런 내부 동작 방식은 평소에 전혀 생각해보지 못했던 부분이라 흥미로웠습니다.
panic! 뒤의 세계를 이렇게 구체적으로 설명해주는 세션은 흔치 않아서
Rust의 안전성이 언어 자체뿐 아니라 **런타임 수준에서도 얼마나 정교하게 설계되어 있는지** 이해할 수 있었던 시간이었습니다.
생각해보지 못했던 주제였지만 **유익하고 재미있게 들은 세션**이었습니다.

### Building a lightning-fast search engine
> `17:45–18:30 · Main Stage`
> 발표자: Clément Renault (Meilisearch 공동 창업자 & CTO)
> [세션 링크](https://eurorust.eu/2025/talks/lightning-fast-search-engine/)

Day 2의 **공식 행사 마지막 세션**이었습니다.
Meilisearch가 프랑스 기반 회사라는 점은 이번에 처음 알게 되었는데,
Rust로 만들어진 대표적인 오픈소스 검색 엔진이라는 인식 이상으로,
**프로젝트가 어떻게 오픈소스에서 시작해 사업화로 이어졌는지**,
그 여정을 구체적으로 들을 수 있어서 매우 인상 깊었습니다.

특히 단순히 기술적 구조나 성능 최적화 이야기가 아니라,
**“하나의 오픈소스 프로젝트를 어떻게 지속 가능한 형태로 발전시켜나가는가”**
라는 점을 실제 경험을 바탕으로 솔직하게 공유해준 점이 좋았습니다.
GlueSQL 프로젝트를 꾸준히 이어가고 있는 제 입장에서도
이야기 전반이 자연스럽게 연결되며 여러 가지 생각을 하게 만들었습니다.
커뮤니티 기반 오픈소스가 어떤 과정을 거쳐 회사로 성장할 수 있는지를
현장의 시선으로 들을 수 있었던 점이 가장 큰 수확이었습니다.

그리고 또 하나 인상적이었던 부분은 **AI에 대한 입장**이었습니다.
Meilisearch 팀은 현재 **AI로 생성된 PR을 받지 않는다는 방침**을 명확히 하고 있었는데,
그 이유와 배경을 솔직하게 이야기해준 부분이 흥미로웠습니다.
요즘 코딩 AI의 발전 속도가 너무 빠르다 보니,
내년쯤에는 이들의 생각이나 정책이 또 어떻게 변해 있을지도 궁금해졌습니다.

기술적인 내용보다도, **오픈소스의 운영·철학·미래 방향성**을 생각하게 한 세션이었고,
EuroRust 2025의 마지막을 마무리하기에 딱 어울리는 발표였습니다.
